<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: eolymp/executor/status.proto

namespace Eolymp\Executor;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Status represents results of the executing task.
 *
 * Generated from protobuf message <code>eolymp.executor.Status</code>
 */
class Status extends \Google\Protobuf\Internal\Message
{
    /**
     * Task reference as set when task was created.
     *
     * Generated from protobuf field <code>string reference = 1;</code>
     */
    protected $reference = '';
    /**
     * Originator of the task (service which created task)
     *
     * Generated from protobuf field <code>string origin = 2;</code>
     */
    protected $origin = '';
    /**
     * Report type, see explanation to Type enumeration
     *
     * Generated from protobuf field <code>.eolymp.executor.Status.Type type = 10;</code>
     */
    protected $type = 0;
    /**
     * Error message for ERROR report
     *
     * Generated from protobuf field <code>string error = 20;</code>
     */
    protected $error = '';
    /**
     * Failure message for FAILURE report
     *
     * Generated from protobuf field <code>string failure = 30;</code>
     */
    protected $failure = '';
    /**
     * Runs for UPDATE report
     *
     * Generated from protobuf field <code>repeated .eolymp.executor.Status.Run runs = 40;</code>
     */
    private $runs;
    /**
     * Source code signature is a unique fingerprint of the code, calculated by agent for a specific language.
     * It should be used to find identical or similar tasks. Signature can be calculated only for some languages.
     *
     * Generated from protobuf field <code>string signature = 50;</code>
     */
    protected $signature = '';
    /**
     * Always increasing report version.
     * Each time agent emits a report it would increase version, so listener can put reports in the right order: process
     * newer and ignore older.
     * In case runs of a single task are distributed among multiple agents, each agent will report version independently,
     * so listener must track versions per run (eg. run #1 last update is v.15, run #2 last update is v.41, if listener
     * receives run #1 v.20 it's newer and should be processed, but run #2 v.20 should be ignored).
     *
     * Generated from protobuf field <code>uint32 version = 100;</code>
     */
    protected $version = 0;
    /**
     * Unique identifier of the agent which executed task.
     *
     * Generated from protobuf field <code>string agent = 110;</code>
     */
    protected $agent = '';

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $reference
     *           Task reference as set when task was created.
     *     @type string $origin
     *           Originator of the task (service which created task)
     *     @type int $type
     *           Report type, see explanation to Type enumeration
     *     @type string $error
     *           Error message for ERROR report
     *     @type string $failure
     *           Failure message for FAILURE report
     *     @type \Eolymp\Executor\Status\Run[]|\Google\Protobuf\Internal\RepeatedField $runs
     *           Runs for UPDATE report
     *     @type string $signature
     *           Source code signature is a unique fingerprint of the code, calculated by agent for a specific language.
     *           It should be used to find identical or similar tasks. Signature can be calculated only for some languages.
     *     @type int $version
     *           Always increasing report version.
     *           Each time agent emits a report it would increase version, so listener can put reports in the right order: process
     *           newer and ignore older.
     *           In case runs of a single task are distributed among multiple agents, each agent will report version independently,
     *           so listener must track versions per run (eg. run #1 last update is v.15, run #2 last update is v.41, if listener
     *           receives run #1 v.20 it's newer and should be processed, but run #2 v.20 should be ignored).
     *     @type string $agent
     *           Unique identifier of the agent which executed task.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Eolymp\Executor\Status::initOnce();
        parent::__construct($data);
    }

    /**
     * Task reference as set when task was created.
     *
     * Generated from protobuf field <code>string reference = 1;</code>
     * @return string
     */
    public function getReference()
    {
        return $this->reference;
    }

    /**
     * Task reference as set when task was created.
     *
     * Generated from protobuf field <code>string reference = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setReference($var)
    {
        GPBUtil::checkString($var, True);
        $this->reference = $var;

        return $this;
    }

    /**
     * Originator of the task (service which created task)
     *
     * Generated from protobuf field <code>string origin = 2;</code>
     * @return string
     */
    public function getOrigin()
    {
        return $this->origin;
    }

    /**
     * Originator of the task (service which created task)
     *
     * Generated from protobuf field <code>string origin = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setOrigin($var)
    {
        GPBUtil::checkString($var, True);
        $this->origin = $var;

        return $this;
    }

    /**
     * Report type, see explanation to Type enumeration
     *
     * Generated from protobuf field <code>.eolymp.executor.Status.Type type = 10;</code>
     * @return int
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * Report type, see explanation to Type enumeration
     *
     * Generated from protobuf field <code>.eolymp.executor.Status.Type type = 10;</code>
     * @param int $var
     * @return $this
     */
    public function setType($var)
    {
        GPBUtil::checkEnum($var, \Eolymp\Executor\Status_Type::class);
        $this->type = $var;

        return $this;
    }

    /**
     * Error message for ERROR report
     *
     * Generated from protobuf field <code>string error = 20;</code>
     * @return string
     */
    public function getError()
    {
        return $this->error;
    }

    /**
     * Error message for ERROR report
     *
     * Generated from protobuf field <code>string error = 20;</code>
     * @param string $var
     * @return $this
     */
    public function setError($var)
    {
        GPBUtil::checkString($var, True);
        $this->error = $var;

        return $this;
    }

    /**
     * Failure message for FAILURE report
     *
     * Generated from protobuf field <code>string failure = 30;</code>
     * @return string
     */
    public function getFailure()
    {
        return $this->failure;
    }

    /**
     * Failure message for FAILURE report
     *
     * Generated from protobuf field <code>string failure = 30;</code>
     * @param string $var
     * @return $this
     */
    public function setFailure($var)
    {
        GPBUtil::checkString($var, True);
        $this->failure = $var;

        return $this;
    }

    /**
     * Runs for UPDATE report
     *
     * Generated from protobuf field <code>repeated .eolymp.executor.Status.Run runs = 40;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getRuns()
    {
        return $this->runs;
    }

    /**
     * Runs for UPDATE report
     *
     * Generated from protobuf field <code>repeated .eolymp.executor.Status.Run runs = 40;</code>
     * @param \Eolymp\Executor\Status\Run[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setRuns($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Eolymp\Executor\Status\Run::class);
        $this->runs = $arr;

        return $this;
    }

    /**
     * Source code signature is a unique fingerprint of the code, calculated by agent for a specific language.
     * It should be used to find identical or similar tasks. Signature can be calculated only for some languages.
     *
     * Generated from protobuf field <code>string signature = 50;</code>
     * @return string
     */
    public function getSignature()
    {
        return $this->signature;
    }

    /**
     * Source code signature is a unique fingerprint of the code, calculated by agent for a specific language.
     * It should be used to find identical or similar tasks. Signature can be calculated only for some languages.
     *
     * Generated from protobuf field <code>string signature = 50;</code>
     * @param string $var
     * @return $this
     */
    public function setSignature($var)
    {
        GPBUtil::checkString($var, True);
        $this->signature = $var;

        return $this;
    }

    /**
     * Always increasing report version.
     * Each time agent emits a report it would increase version, so listener can put reports in the right order: process
     * newer and ignore older.
     * In case runs of a single task are distributed among multiple agents, each agent will report version independently,
     * so listener must track versions per run (eg. run #1 last update is v.15, run #2 last update is v.41, if listener
     * receives run #1 v.20 it's newer and should be processed, but run #2 v.20 should be ignored).
     *
     * Generated from protobuf field <code>uint32 version = 100;</code>
     * @return int
     */
    public function getVersion()
    {
        return $this->version;
    }

    /**
     * Always increasing report version.
     * Each time agent emits a report it would increase version, so listener can put reports in the right order: process
     * newer and ignore older.
     * In case runs of a single task are distributed among multiple agents, each agent will report version independently,
     * so listener must track versions per run (eg. run #1 last update is v.15, run #2 last update is v.41, if listener
     * receives run #1 v.20 it's newer and should be processed, but run #2 v.20 should be ignored).
     *
     * Generated from protobuf field <code>uint32 version = 100;</code>
     * @param int $var
     * @return $this
     */
    public function setVersion($var)
    {
        GPBUtil::checkUint32($var);
        $this->version = $var;

        return $this;
    }

    /**
     * Unique identifier of the agent which executed task.
     *
     * Generated from protobuf field <code>string agent = 110;</code>
     * @return string
     */
    public function getAgent()
    {
        return $this->agent;
    }

    /**
     * Unique identifier of the agent which executed task.
     *
     * Generated from protobuf field <code>string agent = 110;</code>
     * @param string $var
     * @return $this
     */
    public function setAgent($var)
    {
        GPBUtil::checkString($var, True);
        $this->agent = $var;

        return $this;
    }

}

